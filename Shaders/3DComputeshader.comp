#version 430
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;
layout (r8, binding = 0) uniform image3D data;
layout (r8, binding = 1) uniform image3D moved;

/*

uniform sampler1D transferFunc;
uniform vec3 camPos;

uniform int maxRaySteps;
uniform float rayStepSize;
uniform float gradientStepSize;
*/

void main()
{
	ivec3 dims = imageSize(data);	
	ivec3 pixel_coords = ivec3(gl_GlobalInvocationID.xyz);
	vec4 pixel = imageLoad(data, pixel_coords);

	//sets up the circle that will be raycasted
	ivec3 sphere_c = ivec3 (dims.x/2, dims.y/2, dims.z/2);
	float sphere_r = 100.0;

	float length = distance(sphere_c, pixel_coords);
	if (length <= sphere_r/2)
		pixel = vec4(0.2, 0.0, 0.0, 1.0);
	else if (length <= sphere_r/2)
		pixel = vec4(3.0/length, 0.0, 0.0, 1.0);
	else
		pixel = vec4(1.0/length, 0.0, 0.0, 1.0);
	
	imageStore (moved, pixel_coords, pixel);
}

/*

void main()
{
	int i = 0;
	float totalVisibility = 0;
	ivec3 dims = imageSize(data);	
	ivec3 position = ivec3(gl_GlobalInvocationID.xyz);
	vec4 pixel = imageLoad(data, pixel_coords);
	float[1000] opacities;
	vec3[1000] texCoords;

	for (i = 0; i < maxRaySteps; i++)
	{
		float opacity = 0.0f;
		vec3 texCoord = (position + 1.0f)/2.0f;
		float index = imageLoad(data, texCoord).x;

		opacity = vec4(texture(transferFunc, index)).w; 
		opacities[i] = opacity;
		totalVisibility += opacity;

		position = position + (direction * rayStepSize);

		if (abs(position.x) > 1.0f || abs(position.y) > 1.0f || abs(position.z) > 1.0f || absorption >= 1.0f)
			break;
	}
	position = ivec3(gl_GlobalInvocationID.xyz);
	for (int j = 0; j <= i; i++)
	{
		imageStore(moved, texCoord[j], vec4(opacities[j], 0.0, 0.0, 1.0));
	}
}

*/
